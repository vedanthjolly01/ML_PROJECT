# -*- coding: utf-8 -*-
"""ML_Project Raw

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bJBYxuhuDpd3QPhO2zuO6vXE8S8_TCcl
"""

import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder,StandardScaler
from sklearn.metrics import accuracy_score, confusion_matrix, roc_auc_score, roc_curve, classification_report, ConfusionMatrixDisplay
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV

import matplotlib.pyplot as plt
from sklearn.tree import plot_tree
import seaborn as sns

data = pd.read_csv("Zomato Delivery Prediction.csv")
data = data.rename(columns={'Distance_km':'Distance_Km', 'Order_Value_INR': 'Order_Value', 'Rider_Experience_years' : 'Rider_Experience',  'Delivery_Time_min': 'Delivery_Time'})
data.index = data.index + 1
data.head()

data.tail()

data.dtypes

data.shape

data.columns

data.info()

data.nunique()

data.isnull().sum()

x = data.drop('Delivery_Time', axis=1)
y = data['Delivery_Time']

x.head()

y.head()

x = data.drop('Delivery_Time', axis=1)
y = data['Delivery_Time']

categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']

x_encoded = pd.get_dummies(x, columns=[col for col in categorical_cols if col in x.columns], drop_first=False)

display(x_encoded.head())

x_train, x_test, y_train, y_test = train_test_split(x_encoded, y, test_size=0.2, random_state=42, shuffle=True)

x_train.head()

y_train.head()

x_test.head()

y_test.head()

x_train.shape , x_test.shape , y_train.shape , y_test.shape

model = LinearRegression()
model.fit(x_train, y_train)

y_pred = model.predict(x_test)

r2 = r2_score(y_test, y_pred)
print(f"R-squared: {r2:.4f}")

n = x_test.shape[0]
k = x_test.shape[1]
adjusted_R2 = 1 - (1 - r2) * (n - 1) / (n - k - 1)
print(f"Adjusted R-squared: {adjusted_R2:.4f}")

mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error (MSE): {mse:.4f}")

rmse = np.sqrt(mse)
print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")

"""R-squared (R2): Your R2 of 0.8898 means about 89% of the variability in Delivery Time is explained by your chosen features.

Adjusted R-squared: Your Adjusted R2 of 0.8740 confirms the model fits well, accounting for feature count. It's a robust measure of model fit on your data.

Mean Squared Error (MSE): Your MSE of 42.04 means the average squared difference between predicted and actual times is about 42.04 in your dataset.

Root Mean Squared Error (RMSE): Your RMSE of 6.48 minutes indicates the typical prediction error for Delivery Time is around 6.5 minutes in your data.
"""

numeric_data = data[['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience', 'Delivery_Time']]

numeric_correlation_matrix = numeric_data.corr()

plt.figure(figsize=(8, 6))
sns.heatmap(numeric_correlation_matrix, annot=True, cmap='viridis', fmt=".2f")
plt.title('Correlation Matrix of Numeric Features and Delivery Time')
plt.show()

"""This heatmap displays the linear relationships between numeric features and Delivery Time. Each cell's color and value indicate the strength and direction of the correlation. A strong positive correlation (0.76) exists between Distance_km and Delivery Time, indicating longer deliveries for greater distances. Order_Size shows a weak positive correlation (0.16), while Order_Value has a very weak link (0.00). Rider_Experience has a weak negative correlation (-0.07), suggesting slightly shorter times with more experience."""

data_encoded_single = data.copy()

categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
for col in categorical_cols:
    le = LabelEncoder()
    data_encoded_single[col] = le.fit_transform(data_encoded_single[col])

columns_for_correlation = categorical_cols + ['Delivery_Time']
data_for_correlation = data_encoded_single[columns_for_correlation]

correlation_matrix_categorical = data_for_correlation.corr()

delivery_time_correlation_categorical = correlation_matrix_categorical[['Delivery_Time']].sort_values(by='Delivery_Time', ascending=False)

plt.figure(figsize=(8, 6))
sns.heatmap(delivery_time_correlation_categorical, annot=True, cmap='viridis', fmt=".2f")
plt.title('Correlation with Delivery Time (Categorical Features)')
plt.show()

"""This heatmap shows how encoded categorical features linearly relate to Delivery Time. 'Weather' has the strongest positive correlation (0.33) among categorical features, suggesting certain weather conditions impact delivery time more. 'Time_of_Day' shows a weak negative correlation (-0.11), indicating some times might be slightly faster. 'Traffic' (-0.09), 'Restaurant_Popularity' (-0.07), 'Vehicle_Type' (0.05), and 'Cuisine_Type' (0.04) have weaker correlations. Overall, Weather has the most notable linear relationship with Delivery Time among these categorical factors after encoding.


"""

fig, axes = plt.subplots(2, 3, figsize=(14, 8))
axes = axes.flatten()

categorical_features = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']

cmap = plt.get_cmap('viridis')
color_indices = [0.15, 0.95, 0.7, 0.35]
base_colors = [cmap(i) for i in color_indices]

for i, feature in enumerate(categorical_features):
    avg_delivery_time = data.groupby(feature)['Delivery_Time'].mean().reset_index()

    colors = [base_colors[j % 4] for j in range(len(avg_delivery_time))]

    axes[i].pie(
        avg_delivery_time['Delivery_Time'],
        labels=avg_delivery_time[feature],
        autopct='%1.1f%%',
        startangle=140,
        pctdistance=0.7,
        labeldistance=1.1,
        radius=0.35,
        wedgeprops={'edgecolor': 'black', 'linewidth': 1.2},
        textprops={'fontsize': 8},
        colors=colors
    )
    axes[i].set_title(f'Average Delivery Time by {feature}', y=-0.25, fontsize=10)
    axes[i].axis('equal')

if len(categorical_features) < len(axes):
    for j in range(len(categorical_features), len(axes)):
        fig.delaxes(axes[j])

plt.subplots_adjust(wspace=0.7, hspace=0.7)
plt.show()

"""Traffic: High traffic contributes 36.8% of the total average delivery time, Medium 34.1%, Low 29.0%. Delivery times increase as traffic level rises. High traffic slows deliveries significantly, which is expected.

Weather: Stormy: 36.5%, Rainy: 34.2%, Clear: 29.3%. Bad weather (stormy/rainy) increases delivery times. Clear weather results in faster deliveries. Weather is a significant factor affecting delivery efficiency.

Time of Day: Night: 27.7%, Evening: 25.8%, Afternoon: 23.7%, Morning: 22.8%.Deliveries are slower at night, likely due to fewer riders on the road or logistical constraints. Morning deliveries are fastest.

Cuisine Type: Mexican: 26.3%, Indian: 25.0%, Italian: 24.0%, Chinese: 24.7%.Certain cuisines (like Mexican) may take slightly longer to prepare or package, affecting delivery time. Differences are smaller compared to traffic or weather.

Restaurant Popularity: High: 35.0%, Medium: 33.8%, Low: 31.2%. Popular restaurants have longer delivery times, possibly due to higher order volumes and preparation delays.

Vehicle Type: Cycle: 26.6%, Electric: 25.8%, Scooter: 24.6%, Bike: 23.6%. Faster vehicles (like bikes and scooters) deliver quicker, while slower modes (cycle, electric bikes) take longer.
"""

numeric_features = ['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience']
target_variable = 'Delivery_Time'

cmap = plt.get_cmap('viridis')
dark_color = cmap(0.1)

for feature in numeric_features:
    plt.figure(figsize=(8, 6))
    sns.scatterplot(x=data[feature], y=data[target_variable], color=dark_color)
    plt.title(f'Relationship between {feature} and {target_variable}')
    plt.xlabel(feature)
    plt.ylabel(target_variable)
    plt.show()

"""Distance_km vs. Delivery_Time: This scatter plot illustrates the relationship between Distance_km and Delivery Time. It shows a clear positive trend: as Distance_km increases, Delivery Time generally increases as well. This visual pattern supports the strong positive correlation of 0.76 found earlier.

Order_Size vs. Delivery_Time: This scatter plot depicts the relationship between Order_Size and Delivery Time. The points are widely scattered with no apparent upward or downward trend. This indicates a very weak linear relationship, consistent with the low correlation of 0.16.

Order_Value vs. Delivery_Time: This scatter plot visualizes the relationship between Order_Value and Delivery Time. The points are highly dispersed, showing no discernible pattern or trend. This reflects the extremely weak correlation of 0.00 observed previously.

Rider_Experience vs. Delivery_Time: This scatter plot shows the relationship between Rider_Experience and Delivery Time. The points are scattered, and a clear linear trend is not strongly evident. While a weak negative correlation of -0.07 was found, this plot doesn't strongly show delivery time consistently decreasing with experience.

"""

plt.figure(figsize=(12, 6))

cmap = plt.get_cmap('viridis')
yellow_color = cmap(0.95)
purple_color = cmap(0.)

sns.lineplot(x=y_test.index, y=y_test, label='Actual Delivery Time', color=yellow_color, alpha=0.7)
sns.lineplot(x=y_test.index, y=y_pred, label='Predicted Delivery Time', color=purple_color, alpha=0.7)
plt.xlabel("Data Index")
plt.ylabel("Delivery Time")
plt.title("Actual vs Predicted Delivery Time Comparison (Line Plot)")
plt.legend()
plt.show()

"""This line plot compares the Actual Delivery Time with the Predicted Delivery Time over the data index. The yellow line represents the actual delivery times from the test set. The purple line shows the delivery times predicted by your linear regression model. When the predicted line closely follows the actual line, it indicates good model performance. The plot visually demonstrates how well your model's predictions align with the true delivery times.

# Task
Create a Streamlit application that includes all necessary data, charts, and code to run without errors upon deployment, addressing any potential issues encountered during development.

## Install streamlit and other libraries

### Subtask:
Install `streamlit`, `xgboost`, and other required libraries.

**Reasoning**:
The subtask is to install the necessary libraries for the Streamlit application. I will use pip to install `streamlit` and `xgboost`. The other libraries required (`pandas`, `numpy`, `matplotlib`, `sklearn`) are already imported and likely installed in the environment, so I will only explicitly install the ones that caused the error or are specifically mentioned in the instructions and the problematic code cell.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit xgboost

"""## Modify streamlit app

### Subtask:
Integrate the code for generating charts and displaying data into the Streamlit application script.

**Reasoning**:
Integrate the plotting code into the Streamlit application script, ensuring all necessary libraries are imported and visualizations are displayed correctly within the app's structure.
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns  # Import seaborn for heatmaps
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide", page_title="Zomato Delivery Time Predictor", page_icon="🍔")

# Custom CSS for styling the metric cards
st.markdown("""
<style>
.bank-card {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
    background-color: #f9f9f9;
}
.bank-card-header {
    font-weight: bold;
    margin-bottom: 10px;
    color: #333;
}
.metric {
    margin-bottom: 5px;
}
.metric-label {
    font-weight: normal;
    color: #555;
}
.metric-value {
    font-weight: bold;
    color: #007bff;
    margin-left: 5px;
}
</style>
""", unsafe_allow_html=True)


@st.cache_data
def load_and_preprocess_data(file_path):
    """Loads Zomato data, handles missing values, and prepares it for modeling."""
    df = pd.read_csv(file_path)
    df = df.rename(columns={'Distance_km':'Distance_Km', 'Order_Value_INR': 'Order_Value', 'Rider_Experience_years' : 'Rider_Experience',  'Delivery_Time_min': 'Delivery_Time'})

    categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']

    x_raw = df.drop(columns=['Delivery_Time'])
    y = df['Delivery_Time']
    x = pd.get_dummies(x_raw, columns=[col for col in categorical_cols if col in x_raw.columns], drop_first=False)

    return df, x, y

@st.cache_resource
def train_models(x_train_scaled, y_train):
    """Trains regression models."""
    linear_reg = LinearRegression()
    linear_reg.fit(x_train_scaled, y_train)

    tree_reg = DecisionTreeRegressor(max_depth=5, random_state=42)
    tree_reg.fit(x_train_scaled, y_train)

    xgb_reg = XGBRegressor(random_state=42)
    xgb_reg.fit(x_train_scaled, y_train)

    return linear_reg, tree_reg, xgb_reg

st.title("Zomato Delivery Time Predictor ⏱️")
st.write("Enter delivery details in the sidebar to predict the delivery time.")

try:
    df, x, y = load_and_preprocess_data('Zomato Delivery Prediction.csv')

    st.sidebar.header("Delivery Details")
    distance = st.sidebar.number_input("Distance (km)", float(df['Distance_Km'].min()), float(df['Distance_Km'].max()), float(df['Distance_Km'].mean()))
    order_size = st.sidebar.slider("Order Size", int(df['Order_Size'].min()), int(df['Order_Size'].max()), int(df['Order_Size'].mean()))
    traffic = st.sidebar.selectbox("Traffic", df['Traffic'].unique())
    weather = st.sidebar.selectbox("Weather", df['Weather'].unique())
    time_of_day = st.sidebar.selectbox("Time of Day", df['Time_of_Day'].unique())
    cuisine_type = st.sidebar.selectbox("Cuisine Type", df['Cuisine_Type'].unique())
    order_value = st.sidebar.number_input("Order Value (INR)", int(df['Order_Value'].min()), int(df['Order_Value'].max()), int(df['Order_Value'].mean()))
    restaurant_popularity = st.sidebar.selectbox("Restaurant Popularity", df['Restaurant_Popularity'].unique())
    rider_experience = st.sidebar.slider("Rider Experience (years)", int(df['Rider_Experience'].min()), int(df['Rider_Experience'].max()), int(df['Rider_Experience'].mean()))
    vehicle_type = st.sidebar.selectbox("Vehicle Type", df['Vehicle_Type'].unique())

    predict_button = st.sidebar.button("Predict Delivery Time", use_container_width=True)

    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
    scaler = StandardScaler()
    x_train_scaled = scaler.fit_transform(x_train)
    x_test_scaled = scaler.transform(x_test)
    linear_reg, tree_reg, xgb_reg = train_models(x_train_scaled, y_train)

    # Create tabs for different sections
    tab1, tab2, tab3 = st.tabs(["**Delivery Time Prediction**", "**Model Performance Analysis**", "**Data Exploration and Visualizations**"])

    with tab1:
        # Prediction section
        if predict_button:
            input_data = pd.DataFrame({
                'Distance_Km': [distance], 'Order_Size': [order_size], 'Traffic': [traffic], 'Weather': [weather],
                'Time_of_Day': [time_of_day], 'Cuisine_Type': [cuisine_type], 'Order_Value': [order_value],
                'Restaurant_Popularity': [restaurant_popularity], 'Rider_Experience': [rider_experience],
                'Vehicle_Type': [vehicle_type]
            })

            categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
            input_encoded = pd.get_dummies(input_data, columns=[col for col in categorical_cols if col in input_data.columns], drop_first=False)
            input_aligned = input_encoded.reindex(columns=x.columns, fill_value=0)
            input_scaled = scaler.transform(input_aligned)

            predicted_time = xgb_reg.predict(input_scaled)[0]

            st.markdown(f"### Predicted Delivery Time")
            st.metric(label="Estimated Delivery Time", value=f"{predicted_time:.2f} minutes")

        else:
            st.info("Please fill in the delivery details in the sidebar and click 'Predict Delivery Time'.")

    with tab2:
        # Model Performance Analysis section
        st.header("Model Performance Evaluation")

        st.subheader("Performance Metrics on Test Data")
        col1, col2, col3 = st.columns(3)

        y_pred_linear = linear_reg.predict(x_test_scaled)
        y_pred_tree = tree_reg.predict(x_test_scaled)
        y_pred_xgb = xgb_reg.predict(x_test_scaled)

        mse_linear = mean_squared_error(y_test, y_pred_linear)
        rmse_linear = np.sqrt(mse_linear)
        r2_linear = r2_score(y_test, y_pred_linear)

        mse_tree = mean_squared_error(y_test, y_pred_tree)
        rmse_tree = np.sqrt(mse_tree)
        r2_tree = r2_score(y_test, y_pred_tree)

        mse_xgb = mean_squared_error(y_test, y_pred_xgb)
        rmse_xgb = np.sqrt(mse_xgb)
        r2_xgb = r2_score(y_test, y_pred_xgb)

        with col1:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">Linear Regression</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_linear:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_linear:.2f}</span></div></div>""", unsafe_allow_html=True)
        with col2:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">Decision Tree</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_tree:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_tree:.2f}</span></div></div>""", unsafe_allow_html=True)
        with col3:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">XGBoost</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_xgb:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_xgb:.2f}</span></div></div>""", unsafe_allow_html=True)

        st.subheader("Actual vs Predicted Delivery Time")
        # Plotting Actual vs Predicted Delivery Time (Line Plot)
        fig_actual_pred_line, ax_actual_pred_line = plt.subplots(figsize=(12, 6))
        cmap = plt.get_cmap('viridis')
        yellow_color = cmap(0.95)
        purple_color = cmap(0.)

        # Use a subset of the test data for plotting to avoid overcrowding, e.g., first 100 points
        subset_size = min(len(y_test), 200) # Limit to 200 points for clarity
        ax_actual_pred_line.plot(y_test.index[:subset_size], y_test[:subset_size], label='Actual Delivery Time', color=yellow_color, alpha=0.7)
        ax_actual_pred_line.plot(y_test.index[:subset_size], y_pred_xgb[:subset_size], label='Predicted Delivery Time', color=purple_color, alpha=0.7)
        ax_actual_pred_line.set_xlabel("Data Index (Subset)")
        ax_actual_pred_line.set_ylabel("Delivery Time")
        ax_actual_pred_line.set_title(f"Actual vs Predicted Delivery Time Comparison (Line Plot - First {subset_size} points)")
        ax_actual_pred_line.legend()
        st.pyplot(fig_actual_pred_line)

        # Plotting Actual vs Predicted Delivery Time (Scatter Plot)
        st.subheader("Actual vs Predicted Delivery Time (Scatter Plot)")
        fig_pred_scatter, ax_pred_scatter = plt.subplots(figsize=(8, 6))
        ax_pred_scatter.scatter(y_test, y_pred_xgb, alpha=0.5)
        ax_pred_scatter.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
        ax_pred_scatter.set_xlabel("Actual Delivery Time (min)")
        ax_pred_scatter.set_ylabel("Predicted Delivery Time (min)")
        ax_pred_scatter.set_title("Actual vs Predicted Delivery Time (XGBoost)")
        st.pyplot(fig_pred_scatter)


    with tab3:
        # Data Exploration and Visualizations section
        st.header("Data Exploration and Visualizations")

        st.subheader("Correlation Matrix of Numeric Features")
        # Correlation Matrix for Numeric Features
        numeric_data = df[['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience', 'Delivery_Time']]
        numeric_correlation_matrix = numeric_data.corr()
        fig_numeric_corr, ax_numeric_corr = plt.subplots(figsize=(8, 6))
        sns.heatmap(numeric_correlation_matrix, annot=True, cmap='viridis', fmt=".2f", ax=ax_numeric_corr)
        ax_numeric_corr.set_title('Correlation Matrix of Numeric Features and Delivery Time')
        st.pyplot(fig_numeric_corr)

        st.subheader("Correlation with Delivery Time (Encoded Categorical Features)")
        # Correlation with Delivery Time for Encoded Categorical Features
        data_encoded_single = df.copy()
        categorical_cols_for_corr = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
        for col in categorical_cols_for_corr:
            le = LabelEncoder()
            data_encoded_single[col] = le.fit_transform(data_encoded_single[col])

        columns_for_correlation = categorical_cols_for_corr + ['Delivery_Time']
        data_for_correlation = data_encoded_single[columns_for_correlation]
        correlation_matrix_categorical = data_for_correlation.corr()
        delivery_time_correlation_categorical = correlation_matrix_categorical[['Delivery_Time']].sort_values(by='Delivery_Time', ascending=False)
        fig_categorical_corr, ax_categorical_corr = plt.subplots(figsize=(8, 6))
        sns.heatmap(delivery_time_correlation_categorical, annot=True, cmap='viridis', fmt=".2f", ax=ax_categorical_corr)
        ax_categorical_corr.set_title('Correlation with Delivery Time (Categorical Features)')
        st.pyplot(fig_categorical_corr)


        st.subheader("Average Delivery Time by Categorical Features (Pie Charts)")
        # Pie Charts for Average Delivery Time by Categorical Features
        fig_pies, axes_pies = plt.subplots(2, 3, figsize=(14, 10))
        axes_pies = axes_pies.flatten()
        categorical_features_pies = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
        cmap = plt.get_cmap('viridis')
        color_indices = [0.15, 0.95, 0.7, 0.35]
        base_colors = [cmap(i) for i in color_indices]

        for i, feature in enumerate(categorical_features_pies):
            avg_delivery_time = df.groupby(feature)['Delivery_Time'].mean().reset_index()
            colors = [base_colors[j % 4] for j in range(len(avg_delivery_time))]
            axes_pies[i].pie(
                avg_delivery_time['Delivery_Time'],
                labels=avg_delivery_time[feature],
                autopct='%1.1f%%',
                startangle=140,
                pctdistance=0.7,
                labeldistance=1.1,
                radius=0.35,
                wedgeprops={'edgecolor': 'black', 'linewidth': 1.2},
                textprops={'fontsize': 8},
                colors=colors
            )
            axes_pies[i].set_title(f'Average Delivery Time by {feature}', y=-0.25, fontsize=10)
            axes_pies[i].axis('equal')

        if len(categorical_features_pies) < len(axes_pies):
            for j in range(len(categorical_features_pies), len(axes_pies)):
                fig_pies.delaxes(axes_pies[j])

        plt.subplots_adjust(wspace=0.7, hspace=0.7)
        st.pyplot(fig_pies)


        st.subheader("Relationship between Numeric Features and Delivery Time (Scatter Plots)")
        # Scatter Plots for Numeric Features vs. Delivery Time
        numeric_features_scatter = ['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience']
        target_variable = 'Delivery_Time'
        cmap = plt.get_cmap('viridis')
        dark_color = cmap(0.1)

        for feature in numeric_features_scatter:
            fig_scatter, ax_scatter = plt.subplots(figsize=(8, 6))
            sns.scatterplot(x=df[feature], y=df[target_variable], color=dark_color, ax=ax_scatter)
            ax_scatter.set_title(f'Relationship between {feature} and {target_variable}')
            ax_scatter.set_xlabel(feature)
            ax_scatter.set_ylabel(target_variable)
            st.pyplot(fig_scatter)


except FileNotFoundError:
    st.error("Error: `Zomato Delivery Prediction.csv` not found. Please place it in the same directory as your app script.")
except Exception as e:
    st.error(f"An error occurred: {e}")

"""## Review and refine

### Subtask:
Review the modified Streamlit app code to ensure all components are correctly integrated and the app runs without errors.

## Summary:

### Data Analysis Key Findings

*   The necessary libraries, including `streamlit` and `xgboost`, were successfully installed or confirmed to be already present in the environment.
*   The Streamlit application code was successfully modified to include data loading, preprocessing, model training, and visualization components.
*   The application is structured using Streamlit tabs to organize the "Delivery Time Prediction", "Model Performance Analysis", and "Data Exploration and Visualizations" sections.
*   The application incorporates error handling for potential issues like a missing data file.
*   The code for integrating plots (correlation heatmaps, pie charts, scatter plots, and actual vs. predicted line plots) into the Streamlit interface was correctly implemented using `st.pyplot()`.

### Insights or Next Steps

*   The application appears ready for deployment, with all required components integrated.
*   Further refinement could involve adding more interactive elements to the visualizations based on user input.
"""