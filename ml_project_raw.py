# -*- coding: utf-8 -*-
"""ML_Project Raw

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bJBYxuhuDpd3QPhO2zuO6vXE8S8_TCcl
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit xgboost

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns  # Import seaborn for heatmaps
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide", page_title="Zomato Delivery Time Predictor", page_icon="üçî")

# Custom CSS for styling the metric cards
st.markdown("""
<style>
.bank-card {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
    background-color: #f9f9f9;
}
.bank-card-header {
    font-weight: bold;
    margin-bottom: 10px;
    color: #333;
}
.metric {
    margin-bottom: 5px;
}
.metric-label {
    font-weight: normal;
    color: #555;
}
.metric-value {
    font-weight: bold;
    color: #007bff;
    margin-left: 5px;
}
</style>
""", unsafe_allow_html=True)


@st.cache_data
def load_and_preprocess_data(file_path):
    """Loads Zomato data, handles missing values, and prepares it for modeling."""
    df = pd.read_csv(file_path)
    df = df.rename(columns={'Distance_km':'Distance_Km', 'Order_Value_INR': 'Order_Value', 'Rider_Experience_years' : 'Rider_Experience',  'Delivery_Time_min': 'Delivery_Time'})

    categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']

    x_raw = df.drop(columns=['Delivery_Time'])
    y = df['Delivery_Time']
    x = pd.get_dummies(x_raw, columns=[col for col in categorical_cols if col in x_raw.columns], drop_first=False)

    return df, x, y

@st.cache_resource
def train_models(x_train_scaled, y_train):
    """Trains regression models."""
    linear_reg = LinearRegression()
    linear_reg.fit(x_train_scaled, y_train)

    tree_reg = DecisionTreeRegressor(max_depth=5, random_state=42)
    tree_reg.fit(x_train_scaled, y_train)

    xgb_reg = XGBRegressor(random_state=42)
    xgb_reg.fit(x_train_scaled, y_train)

    return linear_reg, tree_reg, xgb_reg

st.title("Zomato Delivery Time Predictor ‚è±Ô∏è")
st.write("Enter delivery details in the sidebar to predict the delivery time.")

try:
    df, x, y = load_and_preprocess_data('Zomato Delivery Prediction.csv')

    st.sidebar.header("Delivery Details")
    distance = st.sidebar.number_input("Distance (km)", float(df['Distance_Km'].min()), float(df['Distance_Km'].max()), float(df['Distance_Km'].mean()))
    order_size = st.sidebar.slider("Order Size", int(df['Order_Size'].min()), int(df['Order_Size'].max()), int(df['Order_Size'].mean()))
    traffic = st.sidebar.selectbox("Traffic", df['Traffic'].unique())
    weather = st.sidebar.selectbox("Weather", df['Weather'].unique())
    time_of_day = st.sidebar.selectbox("Time of Day", df['Time_of_Day'].unique())
    cuisine_type = st.sidebar.selectbox("Cuisine Type", df['Cuisine_Type'].unique())
    order_value = st.sidebar.number_input("Order Value (INR)", int(df['Order_Value'].min()), int(df['Order_Value'].max()), int(df['Order_Value'].mean()))
    restaurant_popularity = st.sidebar.selectbox("Restaurant Popularity", df['Restaurant_Popularity'].unique())
    rider_experience = st.sidebar.slider("Rider Experience (years)", int(df['Rider_Experience'].min()), int(df['Rider_Experience'].max()), int(df['Rider_Experience'].mean()))
    vehicle_type = st.sidebar.selectbox("Vehicle Type", df['Vehicle_Type'].unique())

    predict_button = st.sidebar.button("Predict Delivery Time", use_container_width=True)

    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
    scaler = StandardScaler()
    x_train_scaled = scaler.fit_transform(x_train)
    x_test_scaled = scaler.transform(x_test)
    linear_reg, tree_reg, xgb_reg = train_models(x_train_scaled, y_train)

    # Create tabs for different sections
    tab1, tab2, tab3 = st.tabs(["**Delivery Time Prediction**", "**Model Performance Analysis**", "**Data Exploration and Visualizations**"])

    with tab1:
        # Prediction section
        if predict_button:
            input_data = pd.DataFrame({
                'Distance_Km': [distance], 'Order_Size': [order_size], 'Traffic': [traffic], 'Weather': [weather],
                'Time_of_Day': [time_of_day], 'Cuisine_Type': [cuisine_type], 'Order_Value': [order_value],
                'Restaurant_Popularity': [restaurant_popularity], 'Rider_Experience': [rider_experience],
                'Vehicle_Type': [vehicle_type]
            })

            categorical_cols = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
            input_encoded = pd.get_dummies(input_data, columns=[col for col in categorical_cols if col in input_data.columns], drop_first=False)
            input_aligned = input_encoded.reindex(columns=x.columns, fill_value=0)
            input_scaled = scaler.transform(input_aligned)

            predicted_time = xgb_reg.predict(input_scaled)[0]

            st.markdown(f"### Predicted Delivery Time")
            st.metric(label="Estimated Delivery Time", value=f"{predicted_time:.2f} minutes")

        else:
            st.info("Please fill in the delivery details in the sidebar and click 'Predict Delivery Time'.")

    with tab2:
        # Model Performance Analysis section
        st.header("Model Performance Evaluation")

        st.subheader("Performance Metrics on Test Data")
        col1, col2, col3 = st.columns(3)

        y_pred_linear = linear_reg.predict(x_test_scaled)
        y_pred_tree = tree_reg.predict(x_test_scaled)
        y_pred_xgb = xgb_reg.predict(x_test_scaled)

        mse_linear = mean_squared_error(y_test, y_pred_linear)
        rmse_linear = np.sqrt(mse_linear)
        r2_linear = r2_score(y_test, y_pred_linear)

        mse_tree = mean_squared_error(y_test, y_pred_tree)
        rmse_tree = np.sqrt(mse_tree)
        r2_tree = r2_score(y_test, y_pred_tree)

        mse_xgb = mean_squared_error(y_test, y_pred_xgb)
        rmse_xgb = np.sqrt(mse_xgb)
        r2_xgb = r2_score(y_test, y_pred_xgb)

        with col1:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">Linear Regression</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_linear:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_linear:.2f}</span></div></div>""", unsafe_allow_html=True)
        with col2:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">Decision Tree</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_tree:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_tree:.2f}</span></div></div>""", unsafe_allow_html=True)
        with col3:
            st.markdown(f"""<div class="bank-card"><div class="bank-card-header">XGBoost</div><div class="metric"><span class="metric-label">RMSE:</span><span class="metric-value">{rmse_xgb:.2f}</span></div><div class="metric"><span class="metric-label">R2 Score:</span><span class="metric-value">{r2_xgb:.2f}</span></div></div>""", unsafe_allow_html=True)

        st.subheader("Actual vs Predicted Delivery Time")
        # Plotting Actual vs Predicted Delivery Time (Line Plot)
        fig_actual_pred_line, ax_actual_pred_line = plt.subplots(figsize=(12, 6))
        cmap = plt.get_cmap('viridis')
        yellow_color = cmap(0.95)
        purple_color = cmap(0.)

        # Use a subset of the test data for plotting to avoid overcrowding, e.g., first 100 points
        subset_size = min(len(y_test), 200) # Limit to 200 points for clarity
        ax_actual_pred_line.plot(y_test.index[:subset_size], y_test[:subset_size], label='Actual Delivery Time', color=yellow_color, alpha=0.7)
        ax_actual_pred_line.plot(y_test.index[:subset_size], y_pred_xgb[:subset_size], label='Predicted Delivery Time', color=purple_color, alpha=0.7)
        ax_actual_pred_line.set_xlabel("Data Index (Subset)")
        ax_actual_pred_line.set_ylabel("Delivery Time")
        ax_actual_pred_line.set_title(f"Actual vs Predicted Delivery Time Comparison (Line Plot - First {subset_size} points)")
        ax_actual_pred_line.legend()
        st.pyplot(fig_actual_pred_line)

        # Plotting Actual vs Predicted Delivery Time (Scatter Plot)
        st.subheader("Actual vs Predicted Delivery Time (Scatter Plot)")
        fig_pred_scatter, ax_pred_scatter = plt.subplots(figsize=(8, 6))
        ax_pred_scatter.scatter(y_test, y_pred_xgb, alpha=0.5)
        ax_pred_scatter.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
        ax_pred_scatter.set_xlabel("Actual Delivery Time (min)")
        ax_pred_scatter.set_ylabel("Predicted Delivery Time (min)")
        ax_pred_scatter.set_title("Actual vs Predicted Delivery Time (XGBoost)")
        st.pyplot(fig_pred_scatter)


    with tab3:
        # Data Exploration and Visualizations section
        st.header("Data Exploration and Visualizations")

        st.subheader("Correlation Matrix of Numeric Features")
        # Correlation Matrix for Numeric Features
        numeric_data = df[['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience', 'Delivery_Time']]
        numeric_correlation_matrix = numeric_data.corr()
        fig_numeric_corr, ax_numeric_corr = plt.subplots(figsize=(8, 6))
        sns.heatmap(numeric_correlation_matrix, annot=True, cmap='viridis', fmt=".2f", ax=ax_numeric_corr)
        ax_numeric_corr.set_title('Correlation Matrix of Numeric Features and Delivery Time')
        st.pyplot(fig_numeric_corr)

        st.subheader("Correlation with Delivery Time (Encoded Categorical Features)")
        # Correlation with Delivery Time for Encoded Categorical Features
        data_encoded_single = df.copy()
        categorical_cols_for_corr = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
        for col in categorical_cols_for_corr:
            le = LabelEncoder()
            data_encoded_single[col] = le.fit_transform(data_encoded_single[col])

        columns_for_correlation = categorical_cols_for_corr + ['Delivery_Time']
        data_for_correlation = data_encoded_single[columns_for_correlation]
        correlation_matrix_categorical = data_for_correlation.corr()
        delivery_time_correlation_categorical = correlation_matrix_categorical[['Delivery_Time']].sort_values(by='Delivery_Time', ascending=False)
        fig_categorical_corr, ax_categorical_corr = plt.subplots(figsize=(8, 6))
        sns.heatmap(delivery_time_correlation_categorical, annot=True, cmap='viridis', fmt=".2f", ax=ax_categorical_corr)
        ax_categorical_corr.set_title('Correlation with Delivery Time (Categorical Features)')
        st.pyplot(fig_categorical_corr)


        st.subheader("Average Delivery Time by Categorical Features (Pie Charts)")
        # Pie Charts for Average Delivery Time by Categorical Features
        fig_pies, axes_pies = plt.subplots(2, 3, figsize=(14, 10))
        axes_pies = axes_pies.flatten()
        categorical_features_pies = ['Traffic', 'Weather', 'Time_of_Day', 'Cuisine_Type', 'Restaurant_Popularity', 'Vehicle_Type']
        cmap = plt.get_cmap('viridis')
        color_indices = [0.15, 0.95, 0.7, 0.35]
        base_colors = [cmap(i) for i in color_indices]

        for i, feature in enumerate(categorical_features_pies):
            avg_delivery_time = df.groupby(feature)['Delivery_Time'].mean().reset_index()
            colors = [base_colors[j % 4] for j in range(len(avg_delivery_time))]
            axes_pies[i].pie(
                avg_delivery_time['Delivery_Time'],
                labels=avg_delivery_time[feature],
                autopct='%1.1f%%',
                startangle=140,
                pctdistance=0.7,
                labeldistance=1.1,
                radius=0.35,
                wedgeprops={'edgecolor': 'black', 'linewidth': 1.2},
                textprops={'fontsize': 8},
                colors=colors
            )
            axes_pies[i].set_title(f'Average Delivery Time by {feature}', y=-0.25, fontsize=10)
            axes_pies[i].axis('equal')

        if len(categorical_features_pies) < len(axes_pies):
            for j in range(len(categorical_features_pies), len(axes_pies)):
                fig_pies.delaxes(axes_pies[j])

        plt.subplots_adjust(wspace=0.7, hspace=0.7)
        st.pyplot(fig_pies)


        st.subheader("Relationship between Numeric Features and Delivery Time (Scatter Plots)")
        # Scatter Plots for Numeric Features vs. Delivery Time
        numeric_features_scatter = ['Distance_Km', 'Order_Size', 'Order_Value', 'Rider_Experience']
        target_variable = 'Delivery_Time'
        cmap = plt.get_cmap('viridis')
        dark_color = cmap(0.1)

        for feature in numeric_features_scatter:
            fig_scatter, ax_scatter = plt.subplots(figsize=(8, 6))
            sns.scatterplot(x=df[feature], y=df[target_variable], color=dark_color, ax=ax_scatter)
            ax_scatter.set_title(f'Relationship between {feature} and {target_variable}')
            ax_scatter.set_xlabel(feature)
            ax_scatter.set_ylabel(target_variable)
            st.pyplot(fig_scatter)


except FileNotFoundError:
    st.error("Error: `Zomato Delivery Prediction.csv` not found. Please place it in the same directory as your app script.")
except Exception as e:
    st.error(f"An error occurred: {e}")